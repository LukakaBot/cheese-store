const e='{"documentCount":6,"nextId":6,"documentIds":{"0":"/interview/vue/v-model的作用.html#v-model的作用","1":"/interview/vue/v-model的作用.html#扩展","2":"/interview/vue/v-model的实现原理.html#v-model的实现原理","3":"/interview/vue/vue2数据双向绑定的缺陷.html#vue2-0-双向绑定的缺陷","4":"/interview/vue/vue3实现数据双向绑定的方法.html#vue3-0-实现数据双向绑定的方法","5":"/interview/vue/路由懒加载.html#路由懒加载"},"fieldIds":{"title":0,"titles":1,"text":2},"fieldLength":{"0":[2,1,18],"1":[2,3,14],"2":[2,1,32],"3":[4,1,105],"4":[3,1,41],"5":[1,1,55]},"averageFieldLength":[2.3333333333333335,1.3333333333333333,44.166666666666664],"storedFields":{"0":{"title":"v-model的作用","titles":[]},"1":{"title":"扩展：","titles":["v-model的作用",null]},"2":{"title":"v-model的实现原理","titles":[]},"3":{"title":"Vue2.0 双向绑定的缺陷？","titles":[]},"4":{"title":"Vue3.0 实现数据双向绑定的方法","titles":[]},"5":{"title":"路由懒加载","titles":[]}},"dirtCount":0,"index":[["new",{"2":{"5":2}}],["newvalue",{"2":{"3":2}}],["只需要像往常一样使用foo",{"2":{"5":1}}],["只能追踪到数据是否被修改",{"2":{"3":1}}],["自动代码分割的异步组件",{"2":{"5":1}}],["自html5开始",{"2":{"2":2}}],["返回",{"2":{"5":2}}],["我们可以使用动态",{"2":{"5":1}}],["中",{"2":{"5":1}}],["中新增的一个特性",{"2":{"4":1}}],["组件定义对象",{"2":{"5":2}}],["组件本身",{"2":{"5":1}}],["应该",{"2":{"5":1}}],["该函数返回的",{"2":{"5":1}}],["首先",{"2":{"5":1}}],["webpack",{"2":{"5":3}}],["的工厂函数",{"2":{"5":1}}],["的代码分割功能",{"2":{"5":1}}],["的异步组件和",{"2":{"5":1}}],["的核心优点是可以交由它来处理一些非核心逻辑",{"2":{"4":1}}],["结合这两者",{"2":{"5":1}}],["结合",{"2":{"5":1}}],["然后当路由被访问的时候才加载对应组件",{"2":{"5":1}}],["影响页面加载",{"2":{"5":1}}],["包会变得非常大",{"2":{"5":1}}],["当打包构建应用时",{"2":{"5":1}}],["当创建一个vue实例时",{"2":{"3":1}}],["懒加载",{"2":{"5":1}}],["路由懒加载",{"0":{"5":1}}],["优势",{"2":{"4":1}}],["相比2",{"2":{"4":1}}],["双向数据绑定",{"2":{"4":1}}],["双向绑定的缺陷",{"0":{"3":1}}],["降低对象复杂度等目的",{"2":{"4":1}}],["达到关注点分离",{"2":{"4":1}}],["从而可以让对象只需关注于核心逻辑",{"2":{"4":1}}],["需要验证",{"2":{"4":1}}],["设置对象的某些属性值前",{"2":{"4":1}}],["读取或设置对象的某些属性前记录日志",{"2":{"4":1}}],["如果我们能把不同路由对应的组件分割成不同的代码块",{"2":{"5":1}}],["如果你在vue实例化后添加",{"2":{"3":1}}],["如",{"2":{"4":1}}],["使用proxy实现",{"2":{"4":1}}],["使用",{"2":{"4":1}}],["使用checked属性和change事件",{"2":{"1":1}}],["因此提供了一种机制",{"2":{"4":1}}],["因此我们应该通过",{"2":{"0":1}}],["都必须先通过这层拦截",{"2":{"4":1}}],["外界对该对象的访问",{"2":{"4":1}}],["拦截",{"2":{"4":1}}],["其功能非常类似于设计模式中的代理模式",{"2":{"4":1}}],["其他数组方法及数组的使用则无法检测到",{"2":{"3":1}}],["让我们能够以简洁易懂的方式控制外部对对象的访问",{"2":{"4":1}}],["某些属性的访问控制等",{"2":{"4":1}}],["某些操作",{"2":{"4":1}}],["某些情况下需要对其进行修补或者hack这也是它的缺陷",{"2":{"3":1}}],["用在这里表示由它来",{"2":{"4":1}}],["代理",{"2":{"4":2}}],["翻译过来意思是",{"2":{"4":1}}],["es6",{"2":{"4":1}}],["实现",{"2":{"5":1}}],["实现数据双向绑定是通过proxy",{"2":{"4":1}}],["实现数据双向绑定的方法",{"0":{"4":1}}],["实例创建后",{"2":{"3":1}}],["实例的数据作为数据来源",{"2":{"0":1}}],["对象的响应式实现",{"2":{"3":2}}],["改变传入数组的prototype",{"2":{"3":2}}],["改变get和set",{"2":{"3":1}}],["数组实现响应式",{"2":{"3":2}}],["observe",{"2":{"3":2}}],["obj",{"2":{"3":10}}],["object",{"2":{"3":5}}],["视图更新",{"2":{"3":2}}],["arguments",{"2":{"3":2}}],["array",{"2":{"3":6}}],["重写proto中的数组方法",{"2":{"3":2}}],["foo",{"2":{"5":12}}],["foreach",{"2":{"3":2}}],["function",{"2":{"3":4}}],["component",{"2":{"5":2}}],["const",{"2":{"3":1,"5":3}}],["call",{"2":{"3":2}}],["create",{"2":{"3":2}}],["checkbox",{"2":{"1":1}}],["checked",{"2":{"0":1}}],["复制array",{"2":{"3":2}}],["39",{"2":{"3":32,"5":12}}],["method",{"2":{"3":6}}],["methods",{"2":{"3":4}}],["model=",{"2":{"2":2}}],["model只不过是一个语法糖而已",{"2":{"2":1}}],["model的实现原理",{"0":{"2":1}}],["model的作用",{"0":{"0":1},"1":{"1":1}}],["model在内部为不同的输入元素使用不同的属性并抛出不同的事件",{"2":{"1":1}}],["model会忽略所有表单元素的value",{"2":{"0":1}}],["model",{"2":{"0":1}}],["model本质上不过是语法糖",{"2":{"0":1}}],["具体来说就是重新指定要操作数组的prototype",{"2":{"3":1}}],["通过下面代码简单了解下实现原理",{"2":{"3":1}}],["通过重写数组的array",{"2":{"3":1}}],["通过object",{"2":{"3":1}}],["import",{"2":{"5":2}}],["import语法来定义代码分块点",{"2":{"5":1}}],["isarray",{"2":{"3":2}}],["if",{"2":{"3":4}}],["items",{"2":{"3":4}}],["index",{"2":{"3":4}}],["input方法中",{"2":{"2":2}}],["input每次输入都会触发oninput事件",{"2":{"2":2}}],["input=",{"2":{"2":2}}],["input",{"2":{"2":4}}],["例如如下两种使用方式",{"2":{"3":1}}],["routes",{"2":{"5":2}}],["router",{"2":{"5":2}}],["resolve",{"2":{"5":3}}],["return",{"2":{"3":2}}],["reverse",{"2":{"3":2}}],["reverse七个方法",{"2":{"3":1}}],["radio",{"2":{"1":1}}],["unshift",{"2":{"3":3}}],["path",{"2":{"5":2}}],["point",{"2":{"5":1}}],["pop",{"2":{"3":3}}],["push",{"2":{"3":2}}],["promiseimport",{"2":{"5":1}}],["promise",{"2":{"5":5}}],["proxy",{"2":{"4":3}}],["proxy是",{"2":{"4":1}}],["proto",{"2":{"3":8}}],["prototype",{"2":{"3":8}}],["prototype对应的方法",{"2":{"3":1}}],["propertname",{"2":{"3":2}}],["prop",{"2":{"1":1}}],["这就是如何定义一个能够被",{"2":{"5":1}}],["这样就更加高效了",{"2":{"5":1}}],["这也只限制在数组的push",{"2":{"3":1}}],["这个属性不会被vue处理",{"2":{"3":1}}],["把无法监听数组的情况通过重写数组的部分方法来实现响应式",{"2":{"3":1}}],["不能监听数组的变化",{"2":{"3":1}}],["2",{"2":{"3":1,"5":1}}],["z",{"2":{"3":2}}],["y",{"2":{"3":2}}],["x",{"2":{"3":2}}],["let",{"2":{"3":2}}],["length",{"2":{"3":1}}],["lengthvm",{"2":{"3":1}}],["location",{"2":{"3":4}}],["lt",{"2":{"2":18}}],["data",{"2":{"3":6}}],["defineproperty只能劫持对象的属性",{"2":{"3":1}}],["defineproperty",{"2":{"3":1,"4":1}}],["可以将异步组件定义为返回一个",{"2":{"5":1}}],["可以实现路由组件的懒加载",{"2":{"5":1}}],["可以劫持整个对象",{"2":{"4":1}}],["可以对外界的访问进行过滤和改写",{"2":{"4":1}}],["可以理解成",{"2":{"4":1}}],["可以给子响应式对象重新赋值",{"2":{"3":2}}],["可以用",{"2":{"0":1}}],["响应式对象的子对象新增属性",{"2":{"3":2}}],["jsimport",{"2":{"5":1}}],["jsconst",{"2":{"3":1,"5":3}}],["jsvm",{"2":{"3":1}}],["jsvue",{"2":{"3":1}}],["javascript",{"2":{"0":1,"5":1}}],["解决方案",{"2":{"3":1}}],["一个属性",{"2":{"3":1}}],["或删除",{"2":{"3":1}}],["但是",{"2":{"3":1}}],["但是它并不算是实现数据的响应式的完美方案",{"2":{"3":1}}],["允许vue观察数据的更改并触发更新",{"2":{"3":1}}],["将遍历所有dom对象",{"2":{"3":1}}],["无法检测到对象属性的新增或删除",{"2":{"3":1}}],["100",{"2":{"3":6}}],["1",{"2":{"3":1}}],["主要表现在两个方面",{"2":{"3":1}}],["get和set",{"2":{"3":1}}],["getter",{"2":{"3":1}}],["gt",{"2":{"2":22,"3":2,"5":4}}],["来劫持各个属性的setter",{"2":{"3":1}}],["订阅者模式的方式",{"2":{"3":1}}],["0的object",{"2":{"4":1}}],["0的数据响应是采用数据劫持结合发布者",{"2":{"3":1}}],["0",{"0":{"3":1,"4":1},"2":{"4":1}}],["在路由配置中什么都不需要改变",{"2":{"5":1}}],["在目标对象之前架设一层",{"2":{"4":1}}],["在",{"2":{"2":4,"5":1}}],["在组件的data选项中声明初始值",{"2":{"0":1}}],["就是当前dom的value值",{"2":{"2":2}}],["指代当前触发的事件对象的dom",{"2":{"2":2}}],["指代当前触发的事件对象",{"2":{"2":2}}],["指令在表单及元素上创建双向数据绑定",{"2":{"0":1}}],["于是sth的值就被改变",{"2":{"2":2}}],["所以输入时input的内容会绑定到sth中",{"2":{"2":2}}],["typeof",{"2":{"3":2}}],["this",{"2":{"3":2}}],["target",{"2":{"2":6}}],["textarea",{"2":{"1":1}}],["text",{"2":{"1":1}}],["$event",{"2":{"2":8}}],["===",{"2":{"3":2}}],["=",{"2":{"2":6,"3":16,"5":10}}],["等同于",{"2":{"2":2}}],["split",{"2":{"5":1}}],["splice",{"2":{"3":3}}],["sort",{"2":{"3":3}}],["shift",{"2":{"3":3}}],["set",{"2":{"3":2}}],["select",{"2":{"1":1}}],["selected特性的初始值",{"2":{"0":1}}],["sth",{"2":{"2":10}}],["quot",{"2":{"2":12,"4":2}}],["html",{"2":{"2":1}}],["事件并传递数据",{"2":{"2":1}}],["触发oninput",{"2":{"2":1}}],["绑定响应式数据",{"2":{"2":1}}],["bind",{"2":{"2":1}}],["真正的实现靠的还是",{"2":{"2":1}}],["并返回一个新对象且有13种劫持操作",{"2":{"4":1}}],["并将其prototype指向array",{"2":{"3":2}}],["并将change作为事件",{"2":{"1":1}}],["并重新该prototype中对应上面的7个数组方法",{"2":{"3":1}}],["并为每个数据属性添加了get和set",{"2":{"3":1}}],["并对一些极端场景进行一些特殊处理",{"2":{"0":1}}],["字段将value作为",{"2":{"1":1}}],["元素使用value属性和input事件",{"2":{"1":1}}],["和",{"2":{"1":2}}],["扩展",{"0":{"1":1},"2":{"4":1}}],["而总是将",{"2":{"0":1}}],["它使用了一些hack",{"2":{"3":1}}],["它负责监听用户的输入事件以更新数据",{"2":{"0":1}}],["它会根据控件类型自动选取正确的方法来更新元素",{"2":{"0":1}}],["viewrender",{"2":{"3":2}}],["vm",{"2":{"3":2}}],["value中",{"2":{"2":2}}],["value",{"2":{"2":8,"3":2}}],["value=",{"2":{"2":2}}],["vuerouter",{"2":{"5":2}}],["vue3",{"0":{"4":1},"2":{"4":1}}],["vue实现数组响应式的方法",{"2":{"3":1}}],["vue在实现数组的响应式时",{"2":{"3":1}}],["vue2",{"0":{"3":1},"2":{"3":1}}],["vue",{"2":{"0":1,"3":2,"5":5}}],["v",{"0":{"0":1,"2":1},"1":{"1":1},"2":{"0":3,"1":1,"2":4}}]],"serializationVersion":2}';export{e as default};
