import{_ as s,o as n,c as a,Q as p}from"./chunks/framework.c4bbc6b9.js";const u=JSON.parse('{"title":"Vue2.0 双向绑定的缺陷？","description":"","frontmatter":{},"headers":[],"relativePath":"interview/vue/vue2数据双向绑定的缺陷.md","filePath":"interview/vue/vue2数据双向绑定的缺陷.md","lastUpdated":1696664591000}'),l={name:"interview/vue/vue2数据双向绑定的缺陷.md"},o=p(`<h1 id="vue2-0-双向绑定的缺陷" tabindex="-1">Vue2.0 双向绑定的缺陷？ <a class="header-anchor" href="#vue2-0-双向绑定的缺陷" aria-label="Permalink to &quot;Vue2.0 双向绑定的缺陷？&quot;">​</a></h1><blockquote><p>Vue2.0的数据响应是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty () 来劫持各个属性的setter、getter，但是它并不算是实现数据的响应式的完美方案，某些情况下需要对其进行修补或者hack这也是它的缺陷，主要表现在两个方面：</p></blockquote><p><strong>1. vue 实例创建后，无法检测到对象属性的新增或删除，只能追踪到数据是否被修改(Object.defineProperty只能劫持对象的属性)。</strong></p><p>当创建一个Vue实例时，将遍历所有DOM对象，并为每个数据属性添加了get和set。get和set 允许Vue观察数据的更改并触发更新。但是，如果你在Vue实例化后添加（或删除）一个属性，这个属性不会被vue处理，改变get和set。</p><p>解决方案：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">Vue.</span><span style="color:#B392F0;">set</span><span style="color:#E1E4E8;">(obj, propertName</span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;">index, value)</span></span>
<span class="line"><span style="color:#6A737D;">// 响应式对象的子对象新增属性，可以给子响应式对象重新赋值</span></span>
<span class="line"><span style="color:#E1E4E8;">data.location </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    x: </span><span style="color:#79B8FF;">100</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">    y: </span><span style="color:#79B8FF;">100</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#E1E4E8;">data.location </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {</span><span style="color:#F97583;">...</span><span style="color:#E1E4E8;">data, z: </span><span style="color:#79B8FF;">100</span><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">Vue.</span><span style="color:#6F42C1;">set</span><span style="color:#24292E;">(obj, propertName</span><span style="color:#D73A49;">/</span><span style="color:#24292E;">index, value)</span></span>
<span class="line"><span style="color:#6A737D;">// 响应式对象的子对象新增属性，可以给子响应式对象重新赋值</span></span>
<span class="line"><span style="color:#24292E;">data.location </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    x: </span><span style="color:#005CC5;">100</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">    y: </span><span style="color:#005CC5;">100</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#24292E;">data.location </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> {</span><span style="color:#D73A49;">...</span><span style="color:#24292E;">data, z: </span><span style="color:#005CC5;">100</span><span style="color:#24292E;">}</span></span></code></pre></div><p><strong>2. 不能监听数组的变化</strong></p><p>vue在实现数组的响应式时，它使用了一些hack，把无法监听数组的情况通过重写数组的部分方法来实现响应式，这也只限制在数组的push/pop/shift/unshift/splice/sort/reverse七个方法，其他数组方法及数组的使用则无法检测到，例如如下两种使用方式</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">vm.items[index] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> newValue;</span></span>
<span class="line"><span style="color:#E1E4E8;">vm.items.</span><span style="color:#79B8FF;">length</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">vm.items[index] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> newValue;</span></span>
<span class="line"><span style="color:#24292E;">vm.items.</span><span style="color:#005CC5;">length</span></span></code></pre></div><p>vue实现数组响应式的方法</p><p>通过重写数组的Array.prototype对应的方法，具体来说就是重新指定要操作数组的prototype，并重新该prototype中对应上面的7个数组方法，通过下面代码简单了解下实现原理：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">methods</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> [</span><span style="color:#9ECBFF;">&#39;pop&#39;</span><span style="color:#E1E4E8;">,</span><span style="color:#9ECBFF;">&#39;shift&#39;</span><span style="color:#E1E4E8;">,</span><span style="color:#9ECBFF;">&#39;unshift&#39;</span><span style="color:#E1E4E8;">,</span><span style="color:#9ECBFF;">&#39;sort&#39;</span><span style="color:#E1E4E8;">,</span><span style="color:#9ECBFF;">&#39;reverse&#39;</span><span style="color:#E1E4E8;">,</span><span style="color:#9ECBFF;">&#39;splice&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;push&#39;</span><span style="color:#E1E4E8;">];</span></span>
<span class="line"><span style="color:#6A737D;">// 复制Array.prototype，并将其prototype指向Array.prototype</span></span>
<span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> proto </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Object.</span><span style="color:#B392F0;">create</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">Array</span><span style="color:#E1E4E8;">.</span><span style="color:#79B8FF;">prototype</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">methods.</span><span style="color:#B392F0;">forEach</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">method</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    proto[method] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> () { </span><span style="color:#6A737D;">// 重写proto中的数组方法</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#79B8FF;">Array</span><span style="color:#E1E4E8;">.</span><span style="color:#79B8FF;">prototype</span><span style="color:#E1E4E8;">[method].</span><span style="color:#B392F0;">call</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">...</span><span style="color:#79B8FF;">arguments</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">viewRender</span><span style="color:#E1E4E8;">() </span><span style="color:#6A737D;">// 视图更新</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">observe</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">obj</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (Array.</span><span style="color:#B392F0;">isArray</span><span style="color:#E1E4E8;">(obj)) { </span><span style="color:#6A737D;">// 数组实现响应式</span></span>
<span class="line"><span style="color:#E1E4E8;">                obj.</span><span style="color:#79B8FF;">__proto__</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> proto; </span><span style="color:#6A737D;">// 改变传入数组的prototype</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">typeof</span><span style="color:#E1E4E8;"> obj </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;object&#39;</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">...</span><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;">// 对象的响应式实现</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">})</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">methods</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> [</span><span style="color:#032F62;">&#39;pop&#39;</span><span style="color:#24292E;">,</span><span style="color:#032F62;">&#39;shift&#39;</span><span style="color:#24292E;">,</span><span style="color:#032F62;">&#39;unshift&#39;</span><span style="color:#24292E;">,</span><span style="color:#032F62;">&#39;sort&#39;</span><span style="color:#24292E;">,</span><span style="color:#032F62;">&#39;reverse&#39;</span><span style="color:#24292E;">,</span><span style="color:#032F62;">&#39;splice&#39;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;push&#39;</span><span style="color:#24292E;">];</span></span>
<span class="line"><span style="color:#6A737D;">// 复制Array.prototype，并将其prototype指向Array.prototype</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> proto </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Object.</span><span style="color:#6F42C1;">create</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">Array</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">prototype</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">methods.</span><span style="color:#6F42C1;">forEach</span><span style="color:#24292E;">(</span><span style="color:#E36209;">method</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    proto[method] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> () { </span><span style="color:#6A737D;">// 重写proto中的数组方法</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#005CC5;">Array</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">prototype</span><span style="color:#24292E;">[method].</span><span style="color:#6F42C1;">call</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">...</span><span style="color:#005CC5;">arguments</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">viewRender</span><span style="color:#24292E;">() </span><span style="color:#6A737D;">// 视图更新</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">observe</span><span style="color:#24292E;">(</span><span style="color:#E36209;">obj</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (Array.</span><span style="color:#6F42C1;">isArray</span><span style="color:#24292E;">(obj)) { </span><span style="color:#6A737D;">// 数组实现响应式</span></span>
<span class="line"><span style="color:#24292E;">                obj.</span><span style="color:#005CC5;">__proto__</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> proto; </span><span style="color:#6A737D;">// 改变传入数组的prototype</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">return</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">typeof</span><span style="color:#24292E;"> obj </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;object&#39;</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">...</span><span style="color:#24292E;"> </span><span style="color:#6A737D;">// 对象的响应式实现</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">})</span></span></code></pre></div>`,12),e=[o];function t(c,r,y,E,i,F){return n(),a("div",null,e)}const h=s(l,[["render",t]]);export{u as __pageData,h as default};
