const e='{"documentCount":7,"nextId":7,"documentIds":{"0":"/cheese-store/components/button.html#按钮","1":"/cheese-store/interview/vue/v-model的作用.html#v-model的作用","2":"/cheese-store/interview/vue/v-model的作用.html#扩展","3":"/cheese-store/interview/vue/v-model的实现原理.html#v-model的实现原理","4":"/cheese-store/interview/vue/vue2数据双向绑定的缺陷.html#vue2-0-双向绑定的缺陷","5":"/cheese-store/interview/vue/vue3实现数据双向绑定的方法.html#vue3-0-实现数据双向绑定的方法","6":"/cheese-store/interview/vue/路由懒加载.html#路由懒加载"},"fieldIds":{"title":0,"titles":1,"text":2},"fieldLength":{"0":[1,1,1],"1":[2,1,18],"2":[2,3,14],"3":[2,1,32],"4":[4,1,105],"5":[3,1,41],"6":[1,1,55]},"averageFieldLength":[2.142857142857143,1.2857142857142858,38],"storedFields":{"0":{"title":"按钮","titles":[]},"1":{"title":"v-model的作用","titles":[]},"2":{"title":"扩展：","titles":["v-model的作用",null]},"3":{"title":"v-model的实现原理","titles":[]},"4":{"title":"Vue2.0 双向绑定的缺陷？","titles":[]},"5":{"title":"Vue3.0 实现数据双向绑定的方法","titles":[]},"6":{"title":"路由懒加载","titles":[]}},"dirtCount":0,"index":[["new",{"2":{"6":2}}],["newvalue",{"2":{"4":2}}],["只需要像往常一样使用foo",{"2":{"6":1}}],["只能追踪到数据是否被修改",{"2":{"4":1}}],["自动代码分割的异步组件",{"2":{"6":1}}],["自html5开始",{"2":{"3":2}}],["返回",{"2":{"6":2}}],["我们可以使用动态",{"2":{"6":1}}],["中",{"2":{"6":1}}],["中新增的一个特性",{"2":{"5":1}}],["组件定义对象",{"2":{"6":2}}],["组件本身",{"2":{"6":1}}],["应该",{"2":{"6":1}}],["该函数返回的",{"2":{"6":1}}],["首先",{"2":{"6":1}}],["webpack",{"2":{"6":3}}],["的工厂函数",{"2":{"6":1}}],["的代码分割功能",{"2":{"6":1}}],["的异步组件和",{"2":{"6":1}}],["的核心优点是可以交由它来处理一些非核心逻辑",{"2":{"5":1}}],["结合这两者",{"2":{"6":1}}],["结合",{"2":{"6":1}}],["然后当路由被访问的时候才加载对应组件",{"2":{"6":1}}],["影响页面加载",{"2":{"6":1}}],["包会变得非常大",{"2":{"6":1}}],["当打包构建应用时",{"2":{"6":1}}],["当创建一个vue实例时",{"2":{"4":1}}],["懒加载",{"2":{"6":1}}],["路由懒加载",{"0":{"6":1}}],["优势",{"2":{"5":1}}],["相比2",{"2":{"5":1}}],["双向数据绑定",{"2":{"5":1}}],["双向绑定的缺陷",{"0":{"4":1}}],["降低对象复杂度等目的",{"2":{"5":1}}],["达到关注点分离",{"2":{"5":1}}],["从而可以让对象只需关注于核心逻辑",{"2":{"5":1}}],["需要验证",{"2":{"5":1}}],["设置对象的某些属性值前",{"2":{"5":1}}],["读取或设置对象的某些属性前记录日志",{"2":{"5":1}}],["如果我们能把不同路由对应的组件分割成不同的代码块",{"2":{"6":1}}],["如果你在vue实例化后添加",{"2":{"4":1}}],["如",{"2":{"5":1}}],["使用proxy实现",{"2":{"5":1}}],["使用",{"2":{"5":1}}],["使用checked属性和change事件",{"2":{"2":1}}],["因此提供了一种机制",{"2":{"5":1}}],["因此我们应该通过",{"2":{"1":1}}],["都必须先通过这层拦截",{"2":{"5":1}}],["外界对该对象的访问",{"2":{"5":1}}],["拦截",{"2":{"5":1}}],["其功能非常类似于设计模式中的代理模式",{"2":{"5":1}}],["其他数组方法及数组的使用则无法检测到",{"2":{"4":1}}],["让我们能够以简洁易懂的方式控制外部对对象的访问",{"2":{"5":1}}],["某些属性的访问控制等",{"2":{"5":1}}],["某些操作",{"2":{"5":1}}],["某些情况下需要对其进行修补或者hack这也是它的缺陷",{"2":{"4":1}}],["用在这里表示由它来",{"2":{"5":1}}],["代理",{"2":{"5":2}}],["翻译过来意思是",{"2":{"5":1}}],["es6",{"2":{"5":1}}],["实现",{"2":{"6":1}}],["实现数据双向绑定是通过proxy",{"2":{"5":1}}],["实现数据双向绑定的方法",{"0":{"5":1}}],["实例创建后",{"2":{"4":1}}],["实例的数据作为数据来源",{"2":{"1":1}}],["对象的响应式实现",{"2":{"4":2}}],["改变传入数组的prototype",{"2":{"4":2}}],["改变get和set",{"2":{"4":1}}],["数组实现响应式",{"2":{"4":2}}],["observe",{"2":{"4":2}}],["obj",{"2":{"4":10}}],["object",{"2":{"4":5}}],["视图更新",{"2":{"4":2}}],["arguments",{"2":{"4":2}}],["array",{"2":{"4":6}}],["重写proto中的数组方法",{"2":{"4":2}}],["foo",{"2":{"6":12}}],["foreach",{"2":{"4":2}}],["function",{"2":{"4":4}}],["component",{"2":{"6":2}}],["const",{"2":{"4":1,"6":3}}],["call",{"2":{"4":2}}],["create",{"2":{"4":2}}],["checkbox",{"2":{"2":1}}],["checked",{"2":{"1":1}}],["复制array",{"2":{"4":2}}],["39",{"2":{"4":32,"6":12}}],["method",{"2":{"4":6}}],["methods",{"2":{"4":4}}],["model=",{"2":{"3":2}}],["model只不过是一个语法糖而已",{"2":{"3":1}}],["model的实现原理",{"0":{"3":1}}],["model的作用",{"0":{"1":1},"1":{"2":1}}],["model在内部为不同的输入元素使用不同的属性并抛出不同的事件",{"2":{"2":1}}],["model会忽略所有表单元素的value",{"2":{"1":1}}],["model",{"2":{"1":1}}],["model本质上不过是语法糖",{"2":{"1":1}}],["具体来说就是重新指定要操作数组的prototype",{"2":{"4":1}}],["通过下面代码简单了解下实现原理",{"2":{"4":1}}],["通过重写数组的array",{"2":{"4":1}}],["通过object",{"2":{"4":1}}],["import",{"2":{"6":2}}],["import语法来定义代码分块点",{"2":{"6":1}}],["isarray",{"2":{"4":2}}],["if",{"2":{"4":4}}],["items",{"2":{"4":4}}],["index",{"2":{"4":4}}],["input方法中",{"2":{"3":2}}],["input每次输入都会触发oninput事件",{"2":{"3":2}}],["input=",{"2":{"3":2}}],["input",{"2":{"3":4}}],["例如如下两种使用方式",{"2":{"4":1}}],["routes",{"2":{"6":2}}],["router",{"2":{"6":2}}],["resolve",{"2":{"6":3}}],["return",{"2":{"4":2}}],["reverse",{"2":{"4":2}}],["reverse七个方法",{"2":{"4":1}}],["radio",{"2":{"2":1}}],["unshift",{"2":{"4":3}}],["path",{"2":{"6":2}}],["point",{"2":{"6":1}}],["pop",{"2":{"4":3}}],["push",{"2":{"4":2}}],["promiseimport",{"2":{"6":1}}],["promise",{"2":{"6":5}}],["proxy",{"2":{"5":3}}],["proxy是",{"2":{"5":1}}],["proto",{"2":{"4":8}}],["prototype",{"2":{"4":8}}],["prototype对应的方法",{"2":{"4":1}}],["propertname",{"2":{"4":2}}],["prop",{"2":{"2":1}}],["这就是如何定义一个能够被",{"2":{"6":1}}],["这样就更加高效了",{"2":{"6":1}}],["这也只限制在数组的push",{"2":{"4":1}}],["这个属性不会被vue处理",{"2":{"4":1}}],["把无法监听数组的情况通过重写数组的部分方法来实现响应式",{"2":{"4":1}}],["不能监听数组的变化",{"2":{"4":1}}],["2",{"2":{"4":1,"6":1}}],["z",{"2":{"4":2}}],["y",{"2":{"4":2}}],["x",{"2":{"4":2}}],["let",{"2":{"4":2}}],["length",{"2":{"4":1}}],["lengthvm",{"2":{"4":1}}],["location",{"2":{"4":4}}],["lt",{"2":{"3":18}}],["data",{"2":{"4":6}}],["defineproperty只能劫持对象的属性",{"2":{"4":1}}],["defineproperty",{"2":{"4":1,"5":1}}],["可以将异步组件定义为返回一个",{"2":{"6":1}}],["可以实现路由组件的懒加载",{"2":{"6":1}}],["可以劫持整个对象",{"2":{"5":1}}],["可以对外界的访问进行过滤和改写",{"2":{"5":1}}],["可以理解成",{"2":{"5":1}}],["可以给子响应式对象重新赋值",{"2":{"4":2}}],["可以用",{"2":{"1":1}}],["响应式对象的子对象新增属性",{"2":{"4":2}}],["jsimport",{"2":{"6":1}}],["jsconst",{"2":{"4":1,"6":3}}],["jsvm",{"2":{"4":1}}],["jsvue",{"2":{"4":1}}],["javascript",{"2":{"1":1,"6":1}}],["解决方案",{"2":{"4":1}}],["一个属性",{"2":{"4":1}}],["或删除",{"2":{"4":1}}],["但是",{"2":{"4":1}}],["但是它并不算是实现数据的响应式的完美方案",{"2":{"4":1}}],["允许vue观察数据的更改并触发更新",{"2":{"4":1}}],["将遍历所有dom对象",{"2":{"4":1}}],["无法检测到对象属性的新增或删除",{"2":{"4":1}}],["100",{"2":{"4":6}}],["1",{"2":{"4":1}}],["主要表现在两个方面",{"2":{"4":1}}],["get和set",{"2":{"4":1}}],["getter",{"2":{"4":1}}],["gt",{"2":{"3":22,"4":2,"6":4}}],["来劫持各个属性的setter",{"2":{"4":1}}],["订阅者模式的方式",{"2":{"4":1}}],["0的object",{"2":{"5":1}}],["0的数据响应是采用数据劫持结合发布者",{"2":{"4":1}}],["0",{"0":{"4":1,"5":1},"2":{"5":1}}],["在路由配置中什么都不需要改变",{"2":{"6":1}}],["在目标对象之前架设一层",{"2":{"5":1}}],["在",{"2":{"3":4,"6":1}}],["在组件的data选项中声明初始值",{"2":{"1":1}}],["就是当前dom的value值",{"2":{"3":2}}],["指代当前触发的事件对象的dom",{"2":{"3":2}}],["指代当前触发的事件对象",{"2":{"3":2}}],["指令在表单及元素上创建双向数据绑定",{"2":{"1":1}}],["于是sth的值就被改变",{"2":{"3":2}}],["所以输入时input的内容会绑定到sth中",{"2":{"3":2}}],["typeof",{"2":{"4":2}}],["this",{"2":{"4":2}}],["target",{"2":{"3":6}}],["textarea",{"2":{"2":1}}],["text",{"2":{"2":1}}],["$event",{"2":{"3":8}}],["===",{"2":{"4":2}}],["=",{"2":{"3":6,"4":16,"6":10}}],["等同于",{"2":{"3":2}}],["split",{"2":{"6":1}}],["splice",{"2":{"4":3}}],["sort",{"2":{"4":3}}],["shift",{"2":{"4":3}}],["set",{"2":{"4":2}}],["select",{"2":{"2":1}}],["selected特性的初始值",{"2":{"1":1}}],["sth",{"2":{"3":10}}],["quot",{"2":{"3":12,"5":2}}],["html",{"2":{"3":1}}],["事件并传递数据",{"2":{"3":1}}],["触发oninput",{"2":{"3":1}}],["绑定响应式数据",{"2":{"3":1}}],["bind",{"2":{"3":1}}],["真正的实现靠的还是",{"2":{"3":1}}],["并返回一个新对象且有13种劫持操作",{"2":{"5":1}}],["并将其prototype指向array",{"2":{"4":2}}],["并将change作为事件",{"2":{"2":1}}],["并重新该prototype中对应上面的7个数组方法",{"2":{"4":1}}],["并为每个数据属性添加了get和set",{"2":{"4":1}}],["并对一些极端场景进行一些特殊处理",{"2":{"1":1}}],["字段将value作为",{"2":{"2":1}}],["元素使用value属性和input事件",{"2":{"2":1}}],["和",{"2":{"2":2}}],["扩展",{"0":{"2":1},"2":{"5":1}}],["而总是将",{"2":{"1":1}}],["它使用了一些hack",{"2":{"4":1}}],["它负责监听用户的输入事件以更新数据",{"2":{"1":1}}],["它会根据控件类型自动选取正确的方法来更新元素",{"2":{"1":1}}],["viewrender",{"2":{"4":2}}],["vm",{"2":{"4":2}}],["value中",{"2":{"3":2}}],["value",{"2":{"3":8,"4":2}}],["value=",{"2":{"3":2}}],["vuerouter",{"2":{"6":2}}],["vue3",{"0":{"5":1},"2":{"5":1}}],["vue实现数组响应式的方法",{"2":{"4":1}}],["vue在实现数组的响应式时",{"2":{"4":1}}],["vue2",{"0":{"4":1},"2":{"4":1}}],["vue",{"2":{"1":1,"4":2,"6":5}}],["v",{"0":{"1":1,"3":1},"1":{"2":1},"2":{"1":3,"2":1,"3":4}}],["按钮",{"0":{"0":1}}]],"serializationVersion":2}';export{e as default};
